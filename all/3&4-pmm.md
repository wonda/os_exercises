# 物理内存管理

## 单选题

---

(2009联考)分区分配内存管理方式的主要保护措施是（  ）
- [x] 界地址保护
- [ ] 程序代码保护
- [ ] 数据保护
- [ ] 栈保护

> 为了防止程序的访问地址越界，所以需要进行界地址保护，由硬件负责检查程序访问地址是否合法。
>
> 以ucore为例，在ucore lab1中的，x86保护模式中的分段机制在某种程度上可以看成是一种分区方式的物理内存分配。bootloader在启动后，就要完成分段（分区）工作，即建立两个段，内核代码段和内核数据段，一个段就是一个分区。在表述段属性的段描述符（mmu.h中的segdesc数据结构）中，有两个重要的域（字段，field），起始地址（sd_base_15_0,sd_base_23_16,sd_base_31_24）、段限长(sd_lim_15_0,sd_lim_19_16)。这个段大小就是分区的界地址。80386 CPU在每一次内存寻址过程中，都会比较EIP（即段内偏移）是否大于段限长，如果大于段限长，这会产生一个内存访问错误异常。

(2010联考)某基于动态分区存储管理的计算机，其主存容量为55MB（初始为空），采用最佳适配（Best Fit）算法，分配和释放的顺序为：分配15MB，分配30MB，释放15MB，分配8MB，分配6MB，则此时主存中最大空闲分区的大小是（  ）
- [ ] 7MB
- [x] 9MB
- [ ] 10MB
- [ ] 15MB

> 空闲分区链变化：55（初始）；40（分配15MB后）；10（分配30MB后）；10->15（释放15MB后）；2->15（分配8MB后）；2->9（分配6MB后）。
>
> 以ucore为例，能否在ucore中做个试验完成上述算法？

(2009联考）一个分段存储系统中，地址长度为32位，其中段号占8位，则最大段长为（  ）
- [ ] 2^8字节
- [ ] 2^16字节
- [x] 2^24字节
- [ ] 2^32字节

> 在段访问机制中，如果采用的是单地址方案，则段号的位数+段内偏移的位数=地址长度，所以段内偏移占了32 - 8 = 24 比特。
>
> 以ucore lab1为例，在段访问机制上，80386采用了不同，且更加灵活的段寄存器+地址寄存器方案，(可看OS原理部分的"物理内存管理：第2部分"ppt的第10页)，即CS中的值（称为选择子，selector）是段号，作为索引，指向了一个段描述符表中的一个段描述符。
> 段描述符中的一个字段是段基址（32位），这个32位段基址+段内偏移（即32位的EIP）形成了最终的线性地址（如果使能页机制，则也就是最终的物理地址了）。
> 所以，如果是这道题说明了采用80386方式，结果就不一样了。

(2010联考）某计算机采用二级页表的分页存储管理方式，按字节编址，页大小为2^10字节，页表项大小为2字节，逻辑地址结构为“|页目录号|页表|页内偏移量|”逻辑地址空间大小为2^16页，则表示整个逻辑地址空间的页目录表中包含表项的个数至少为（  ）
- [ ] 64
- [x] 128
- [ ] 256
- [ ] 512

> 页大小为2^10B，页表项大小为2B，一页可以存放2^9个页表项，逻辑地址空间大小为2^16页，需要2^16个页表项，需要2^16/2^9 = 2^7 = 128个页面保存页表项。所以页目录表中包含的表项至少为128。
>
> 以ucore lab2为例，80386保护模式在使能页机制后，采用的是二级页表，32位地址空间，页大小为2^12字节，页表项为4字节，逻辑地址结构为“|页目录号|页表|页内偏移量|”逻辑地址空间大小为2^20页，则也目录表包含的表项个数为1024.  你觉得对吗？

(武汉理工大学）段式存储管理系统中，一个程序如何分段是在（  ）决定的。
- [ ] 分配主存时
- [x] 程序员编程时
- [ ] 装作业时
- [ ] 程序执行时

> 程序员在编程时，其实已经确定了哪些是代码，哪些是数据。所以编译器可以把代码放到代码段，数据放到数据段，操作系统可以根据编译器的设置把程序加载到内存中的代码段和数据段执行。
>
> 以ucore lab1为例，学员编写文件有代码和数据两部分，gcc把代码放到代码段，数据放到数据段，并形成ELF格式的ucore kernel（这其实也是一个程序）。bootloader把ucore的代码或数据放到它设置好的内核代码段和内核数据段中。ucore lab5以后，ucore也可以加载应用程序到用户代码段和用户数据段中。

一般情况下，\_\_\_\_的速度最快
- [x] L1 cache
- [ ] L2 cache
- [ ] Main Memory
- [ ] Disk

> 解释：访问速度上 cache > Main Memory > Disk; cache中 L1 > L2 > L3 ... 越靠近cpu速度越快，容量越小。
>
> 这个在qemu模拟器中无法体现，因为它没有模拟不同存储之间的访问速度。 :(


分页系统中, 逻辑地址到物理地址的变换是由\_\_\_\_决定的
- [ ] 段表
- [x] 页表
- [ ] 物理结构
- [ ] 重定位寄存器

> 解释：分页系统中，页表负责转换逻辑地址到物理地址。

分段系统中, 逻辑地址到物理地址的变换是由\_\_\_\_决定的
- [x] 段表
- [ ] 页表
- [ ] 物理结构
- [ ] 重定位寄存器

> 解释：看看ucore lab1，了解bootloader和ucore是如何建立段表的。

连续内存分配算法中的First Fit（首次适应）算法，其空闲分区链的顺序为\_\_\_\_
- [x] 空闲区首地址递增
- [ ] 空闲区首地址递减
- [ ] 空闲区大小递增
- [ ] 空闲区大小递减

> 解释：First Fit是指按地址来寻找第一个满足要求的空闲块，其空闲分区链的顺序也就是按空闲块首地址递增。
>
> 以ucore为例，能否在ucore中做个试验完成上述算法？

连续内存分配算法中的Best Fit（最佳适应）算法，其空闲分区链的顺序为\_\_\_\_
- [ ] 空闲区首地址递增
- [ ] 空闲区首地址递减
- [x] 空闲区大小递增
- [ ] 空闲区大小递减

> 解释：Best Fit是指寻找一个大小最合适的空闲块，要求空闲块按照大小排列，其空闲分区链的顺序为按大小递增。
>
> 以ucore为例，能否在ucore中做个试验完成上述算法？

连续内存分配算法First Fit的缺点是\_\_\_\_
- [ ] 算法复杂
- [ ] 大的空闲分区会被分割
- [x] 容易产生外部碎片
- [ ] 分配速度慢

> 解释：First Fit算法非常简单，分配速度也较快。但是First Fit不考虑实际的需求和找到的空闲分区的大小的匹配度，所以容易产生外部碎片。
>
> 以ucore为例，能否在ucore中做个试验完成上述算法并看看其缺点能否重现？

连续内存分配算法Best Fit的缺点是\_\_\_\_
- [ ] 算法复杂
- [ ] 大的空闲分区会被分割
- [ ] 分配速度慢
- [x] 回收速度慢

> 解释：Best Fit算法也非常简单，分配速度较快。由于选取的空闲分区大小都很合适，所以基本不会出现大的空闲分区总是被分割的情况。但是在此算法中，内存回收则涉及了很多操作：判断左右邻居是否是空闲分区，如果不是，则插入此空闲分区到合适的地方，如果是则合并空闲块，并把合并后的结果插入到合适地方；但是由于空闲分区链不是按地址排序的，所以上述操作需要遍历几次链表用于查找和插入，速度较慢。

连续内存分配算法Worst Fit的缺点是\_\_\_\_
- [ ] 算法复杂
- [x] 大的空闲分区会被分割
- [ ] 分配速度慢
- [ ] 容易产生很小的空闲分区

> 解释：Worst Fit每次使用最大的空闲分区，按照需求分割相应的大小，所以会造成大的空闲分区总是被分割。其算法比较简单，分配速度也很快。
>
> 以ucore为例，能否在ucore中做个试验完成上述算法并看看其缺点能否重现？

应用程序中的逻辑地址到物理内存中的物理地址的转换机制建立的过程发生\_\_\_\_程序过程中
- [ ] 编译
- [ ] 链接
- [x] 加载
- [ ] 运行

> 解释：在编译器编译和链接程序的过程中都只涉及到逻辑地址，跟机器的配置无关，这也是编译链接所生成的可执行文件可以直接在相同系统的其它机器上使用的原因。而在操作系统加载应用程序时，操作系统负责建立应用程序的段表或页表。将逻辑地址和实际物理地址对应起来，之后应用程序在运行过程中CPU才能根据逻辑地址通过段表或页表正确访问到物理地址。
>
> 以ucore lab5为例，在加载应用程序时，将建立应用程序对应的进程，并在建立过程中，把应用程序对应进程的页表也建立好了。

某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改空闲区表，如果待回收的空闲区有相邻的低址空闲区,也有相邻的高址空闲区，那么空闲区表将\_\_\_\_
- [ ] 项数不变，有一个空闲区的大小变大
- [ ] 项数不变，有一个空闲区的起始地址变小，大小变大
- [ ] 项数增加
- [x] 项数减少

> 解释：合并之后，原本的2个相邻空闲分区和被回收的分区合并成一个分区，所以分区项数变为n - 2 + 1 = n - 1。
>
> 以ucore为例，能否在ucore中做个试验完成上述相邻空闲区合并功能，看看合并的效果如何？

对于分页系统与分段系统,下列说法正确的是( ).
- [ ] 页的大小跟具体执行程序有关
- [x] 都属于非连续分配
- [ ] 段的大小固定且由系统确定
- [ ] 分段技术和分页技术是不能共存在一个系统中的

> 解释：页的大小由CPU硬件规定的规范，并由操作系统进行初始化和管理，跟具体执行程序无关； 段的大小是指程序的数据段、代码段等每段的大小，和具体程序相关；分段技术和分页技术是按照需求进行动态的分配和回收，是非连续分配，它们可以融合使用，也称段页式管理。
>
> 以ucore为例，在lab2之后，就采用基于80386的段页式管理了，但段机制的功能没有太用。

采用段页式管理时，程序按逻辑被划分成\_\_\_\_
- [x] 段
- [ ] 页
- [ ] 区域
- [ ] 块

> 解释：程序按逻辑划分各段。而页、区域、块由操作系统负责分配、映射和管理，和程序逻辑没有关系。


采用段页式管理的多道程序环境下，一个应用程序都有对应的\_\_\_\_
- [x] 一个段表和一个页表
- [ ] 一个段表和一组页表
- [ ] 一组段表和一个页表
- [ ] 一组段表和一组页表

> 解释：每道程序有一个段表，且还要有一个页表，才能完成段页式的内存管理。
>
> 以ucore为例，在lab5之后，就采用基于80386的段页式管理了，一个程序有一个段表，也有一个页表。

在分页式存储管理系统中时，每次CPU取指令或取操作数，至少要访问\_\_\_\_次主存。
- [x] 0
- [ ] 1
- [ ] 2
- [ ] 3

> 解释：0次。因为CPU会有cache和mmu
>
> 以ucore为例，在80386中，如果取的指令和取的操作数都在CPU的cache中，且放在页表中的地址映射关系被缓存在CPU的MMU中，则不需要访问主存。

在分段式存储管理系统中时，每次CPU取指令或取操作数，至少要访问\_\_\_\_次主存。
- [x] 0
- [ ] 1
- [ ] 2
- [ ] 3

> 解释：0次。因为CPU会有cache，mmu和对段表项的缓存
>
> 以ucore为例，在80386中，如果取的指令和取的操作数都在CPU的cache中，且放在段表中的地址映射关系被缓存在CPU的段表项缓存中，则不需要访问主存。

在段页式存储管理系统中时，每次CPU取指令或取操作数，至少要访问\_\_\_\_次主存。
- [x] 0
- [ ] 1
- [ ] 2
- [ ] 3

> 解释：0次。因为CPU会有cache和对段表项的缓存
> 以ucore为例，在80386中，如果取的指令和取的操作数都在CPU的cache中，且放在段表中的地址映射关系被缓存在CPU的段表项缓存中，且放在页表中的地址映射关系被缓存在CPU的MMU中，则不需要访问主存。

每道程序能在不受干扰的环境下运行，主要是通过\_\_\_\_功能实现的。
- [ ] 内存分配
- [x] 内存保护
- [ ] 内存回收
- [ ] 内存扩充

> 解释：内存访问需要将逻辑地址和重定位寄存器(基址寄存器)进行加运算之后才能访问物理地址，而内存保护主要是使用界地址寄存器来实现对逻辑地址的限制，以免逻辑地址越界而造成物理地址访问越界，进而对别的程序进行干扰。
>
> 以ucore为例，在lab5中，ucore对每个应用程序设置的页表，可以完成对不同程序的地址空间的隔离，从而避免了程序间可能的干扰。

可变分区存储管理方案中\_\_\_\_作为存储保护使用。
- [ ] 逻辑地址寄存器
- [x] 长度寄存器
- [ ] 物理地址寄存器
- [ ] 基址寄存器

> 解释：长度寄存器或称界地址寄存器，用于存储保护。
>
> 以ucore为例，在80386中，分段机制可以看成是一种可变分区存储管理方案，其段描述符中的段限长字段类似这里提到的“长度寄存器“

分页系统中的页面对\_\_\_\_透明，是\_\_\_\_管理的。
- [ ] 程序员、编译器
- [x] 程序员、操作系统
- [ ] 操作系统、编译器
- [ ] 程序员、链接器

> 解释：分页由操作系统控制，用户并不能感知。
>
> 以ucore为例，在lab5以后，程序员写应用程序，确实不需要考虑有分页机制的存在。因为ucore已经为每个应用程序建立好了段表（也叫全局描述符表，简称GDT）和页表。

---

## 多选题

---

关于分段系统和分页系统说法正确有\_\_\_\_。
- [x] 页是系统层面的内存管理的单位，分页的目的主要是由于操作系统管理的需要；段是编写程序层面的内存管理的单位,分段的目的主要是为了能更好地满足程序员开发的需要
- [x] 页的大小是固定的，而且由系统确定。段的长度却是不固定的，决定于程序员所编写的程序
- [x] 分段系统会产生外碎片，分页系统会产生内碎片
- [x] 分段可灵活的控制存取访问，可根据各段的特点决定访问权

> 解释：1,2,4解释略。3：分段系统中段的大小是跟程序相关的，分段系统中每次分配的大小就是相应段的真实大小所以没有内部碎片；但是却会产生不满足任何段大小的空闲分区，就是外部碎片。




---
