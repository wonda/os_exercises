# 信号量

##单选题

---

临界区是指()
- [ ] 并发进程中用于实现进程互斥的程序段
- [x] 进程中访问临界资源的那段代码
- [ ] 一段缓冲区
- [ ] 一个数据区

> 解释：每个进程有一个代码段称为临界区，在该区中进程可能改变共同变量、更新一个表、写一个文件等。

多个进程对信号量S进行了6次P操作，2次V操作后，现在信号量的值是-3，与信号量S相关的处于阻塞状态的进程有几个（）
- [ ] 1个
- [ ] 2个
- [x] 3个
- [ ] 4个

> 解释：信号量的当前值为-3，当信号量<=0时，再次执行wait()操作，信号量值减一，同时该进程阻塞自己，将其放入到与信号量相关的等待队列中，并将该进程的状态切换到等待状态，所以可以得到答案

2元信号量可以初始化为（）
- [x] 0或1
- [ ] 0或-1
- [ ] 只能为1
- [ ] 任意值

> 解释：通常操作系统区分计数信号量与二进制信号量，二进制信号量的值只能为0或1

在信号量中wait()和signal()操作的意义分别是（）
- [ ] +0 -1
- [ ] +1 -1
- [ ] +0 +1
- [x] -1 +1

> 解释：除了初始化外，信号量只能通过两个标准原子操作：wait()和signal()来访问，分别为信号量减一和加一

进程P1有语句S1，进程P2有语句S2，P1和P2共享一个信号量sem，且初始化为0,P1的语句为：S1; signal(sem);  P2的语句为： wait(sem); S2; 这样的效果是（）
- [ ] S1和S2一起执行
- [ ] S1执行，S2不执行
- [x] 只有S1执行完后才执行S2
- [ ] 只有S2执行完后才执行S1

> 解释：因为sem初始化为0，P2只有在P1调用signal(sem) (即S1)之后，才会执行S2

自旋锁会要求忙等待，会浪费CPU时钟，但是它也有优点，自旋锁的优点是（）
- [ ] 不用阻塞
- [x] 等待锁时不进行上下文切换
- [ ] 不会出现死锁
- [ ] 不会出现饥饿

> 解释：自旋锁的主要缺点是都要求忙等待，当一个进程位于其临界区内时，任何其他试图进入其临界区的进程都必须在其进入代码中连续地循环，但是它也有其自身的优点，进程在等待时不进行上下文切换，而上下文切换可能需要花费相当长时间

假设一个进程用wait(mutex)替代了signal(mutex),如下，会产生什么现象（）

	    wait(mutex);
		...
		critical section
		...
	    wait(mutex);

- [x] 死锁
- [ ] 饥饿
- [ ] 忙等待
- [ ] 什么也没有

> 解释：因为wait(mutex)之后，并没有对信号量进行增加，当再执行wait(mutex),可能会因为等待信号量而出现死锁

以下关于P、V操作描述正确的是（）
- [ ] 机器指令
- [ ] 系统调用
- [x] 低级通信原语
- [ ] 高级通信原语

> 解释：除了初始化外，信号量只能通过两个标准原子操作：wait()和signal()来访问，这些操作原来被称为P和V

(2010年计算机联考)设与某资源关联的信号量（K）初值为3，当前值为1.若M表示该资源的可用个数，N表示等待该资源的进程数，则M、N分别是（）
- [ ] 0、1
- [x] 1、0
- [ ] 1、2
- [ ] 2、0

> 解析：信号量表示当前可用的相关资源数。当信号量K>0时，表示还有K个相关资源可用；而当信号量K<0时，表示有|K|个进程在等待该资源。所以该资源可用数是1，等待该资源的进程数是0

(2011年全国统考)有两个并发执行的进程P1和P2，共享初值为1的变量x。P1对x加1，P2对x减一。加1和减1操作的指令序列分别如下所示,两个操作完成后，x的值（）。

	加一操作    		减一操作
	Load R1,x  		load R2,x
	inc R1     		dec R2
	store x,R1 		store x,R2

- [ ] 可能为-1或3
- [ ] 只能为1
- [x] 可能为0、1或2
- [ ] 可能为-1、0、1、1或2

> 解析：依次执行P1-1，P1-2，P1-3，P2-1，P2-2，P2-3，得到的结果是1；依次执行P1-1，P1-2，P2-1，P2-2，P2-3，P1-3，得到的结果是2；依次执行P2-1，P2-2，P1-1，P1-2，P1-3，P2-3得到的结果是0

（电子科技大学）不是信号量能实现的功能是（）
- [ ] 进程同步
- [ ] 进程互斥
- [ ] 执行的前趋关系
- [x] 进程的并发执行

> 解析：考察信号量的功能，信号量可以用于实现进程间的同步和互斥，可以描述并发进程执行的前趋关系。

（兰州大学）原语是（）
- [ ] 运行在用户态下的过程
- [ ] 操作系统的内核
- [ ] 可中断的指令序列
- [x] 不可中断的指令序列

> 解析：考察原语的基本概念，原语最大特点是执行过程不可中断

（武汉理工大学）用V操作唤醒一个等待进程时，被唤醒的进程状态变为（）
- [ ] 运行
- [ ] 等待
- [x] 就绪
- [ ] 完成

> 解析：考察PV操作的实现

（武汉理工大学）用来实现进程同步与互斥的PV操作实际上是由（）过程组成的
- [ ] 一个可被中断的
- [x] 一个不可被中断的
- [ ] 两个可被中断的
- [ ] 两个不可被中断的

> 解析：PV原语通过操作信号量来处理进程间的同步与互斥问题。其核心就是一段不可分割不可中断的程序

（上海交通大学）用PV操作实现进程同步，信号量的初值（）
- [ ] -1
- [ ] 0
- [ ] +1
- [x] 由用户确定

> 解析：用PV操作实现同步时，一定要根据具体情况来定义信号量和调用P操作或V操作

（青岛大学）设系统有10个并发进程通过PV操作原语共享同一临界资源，若该临界资源互斥信号量为MUTEX，则MUTEX的值域为（）
- [ ] [-10,0]
- [ ] [0,10]
- [x] [-9,1]
- [ ] [-1,9]

> 解析：用信号量实现进程的互斥，初值一般设为1，而每个进程执行一次P操作后，信号量值减1

（南航）要实现两个进程互斥，设一个互斥信号量mutex，当mutex为0时，表示（）
- [ ] 没有进程进入临界区
- [ ] 没有一个进程进入临界区
- [x] 有一个进程进入临界区，另外一个进程在等待
- [ ] 两个进程都进入临界区

> 解析：在使用信号量实现进程之间的互斥时，其初值为1，现在mutex为0，说明1个进程进入临界区

---

##多选题

---

（哈工大）以下（）属于临界资源
- [x] 打印机
- [ ] 非共享数据
- [x] 共享变量
- [x] 共享缓冲区

> 解析：在该题中除了非共享数据都是只能允许一个一个进程使用

信号量原子执行的问题，一般情况下通过哪两种方式解决（）
- [x] 单处理器中在执行wait()和signal()操作时禁止中断
- [ ] 多处理器中在执行wait()和signal()操作时禁止中断
- [ ] 在单处理器中提供其他加锁机制（如自旋锁）
- [x] 在多处理器中提供其他加锁机制（如自旋锁）

> 解释：信号量的关键之处是它们原子地执行，必须确保没有两个进程能同时对同一信号量执行wait()和signal()操作，通过两种方法解决，即答案中所述。

以下信号量的物理含义，正确的是（）
- [x] S>0表示有S个资源可用
- [x] S<0则|S|表示S等待队列中的进程个数
- [x] P(S)表示申请一个资源
- [x] V(S)表示释放一个资源

> 解释：信号量的物理含义，信号量大于0表示有多少资源可用，小于0表示S等待队列中的进程个数，P、V操作分别使申请和释放资源

采用PV同步机制来编写并发程序，对于共享变量及信号量变量的操作将被分散于各个进程中的缺点有（）
- [x] 易读性差
- [x] 不利于修改和维护
- [x] 正确性难以保证
- [x] 使用起来容易出错

> 解释：概念题，PV同步机制来编写并发程序有易读性差，不利于修改和维护，正确性难以保证，并且容易出错

管程的主要特点有（）
- [x] 局部数据变量只能被管程的过程访问
- [x] 一个进程通过调用管程的一个过程进入管程
- [ ] 不会出现死锁
- [x] 在任何时候，只能有一个进程在管程中执行

> 解释：管程类型的表示包括一组变量的声明和对这些变量操作的子程序和函数的实现。管程类型的表示不能直接为各个进程所使用，因此在管程内定义的子程序只能访问位于管程内那些局部声明的变量和形式参数

管程由以下哪些组成（）
- [x] 一个或多个过程
- [x] 局部数据
- [x] 一个初始化序列
- [ ] 一个链表

> 解释：管程由局部数据，一个或多个过程以及1个初始化序列组成

---

##判断题

---

信号量的初值必须是大于零的整数（）
- [ ] 对
- [x] 错

> 解析：错误，信号量初值为非负的整数变量

每个信号量都有整形值和一个进程链表（）
- [x] 对
- [ ] 错

> 解释：每个信号量都有一个整形值和一个进程链表组成，当1个进程必须等待信号量时，就加入到进程链表中

通常在进程对信号量减1之前，无法提前知道该信号量是否会阻塞（）
- [x] 对
- [ ] 错

> 解释：只有在信号量减一后小于0，信号量才会自身阻塞

无论如何使用信号量都不会产生死锁问题（）
- [ ] 对
- [x] 错

> 解释：信号量不正确使用容易产生死锁问题

管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有管程才能访问（）
- [x] 对
- [ ] 错

> 解释：概念定义

在管程中的signal()与信号量中的signal()操作实现及意义完全相同（）
- [ ] 对
- [x] 错

> 解释：在管程中的signal()会重新启动一个悬挂的进程。如果没有进程悬挂，那么操作signal()就没有作用；即如同没有执行，这一操作与信号量相关的操作signal（）不同，后者能影响信号量的状态

管程中的局部数据变量可以被外部直接访问（）
- [ ] 对
- [x] 错

> 解释：管程中的局部数据变量只能由管程内定义的过程来进程访问，不能被外部直接访问

当一个进程在管程中执行时，调用管程的其他进程都不会被阻塞（）
- [ ] 对
- [x] 错

> 解释：当一个进程在管程中执行时，调用管程的其他进程都会被阻塞，这样才能保持同步性

---
