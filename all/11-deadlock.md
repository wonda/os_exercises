# 死锁和进程间通信

##单选题

---

若P,V操作的信号量S初值为4,当前值为-1,则表示有（）进程处于等待状态。
- [ ] 0
- [x] 1
- [ ] 2
- [ ] 3

>p操作会使s减1，如果s<0，则p操作进程进入等待；v操作会使s加1，如果s<=0,则会唤醒一个等待的程序。处于等待状态的进程的数目只和信号量当前值有关，而和信号量的初始值无关。

任何两个并发进程之间（）。
- [ ] 一定存在互斥关系
- [ ] 一定存在同步关系
- [ ] 一定彼此独立无关
- [x] 可能存在同步或互斥关系

>如果两个并发程序为互斥关系，则必定存在临界区，但是实际上不是多有的并发程序之间都存在临界区；我们把异步环境下的一组并发进程因直接制约而互相发送消息、进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程间的同步，实际上不是所有的程序间都存在直接制约关系。所有两个并发的程序之间只是有可能存在同步或互斥关系。

银行家算法是一种（）算法。
- [ ] 死锁解除
- [x] 死锁避免
- [ ] 死锁预防
- [ ] 死锁检测

>银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。

在为多道程序所提供的可共享的系统资源不足时，可能出现死锁。但是，不适当的（）也可能产生死锁。
- [ ] 进程优先权
- [ ] 资源的线性分配
- [x] 进程推进顺序
- [ ] 分配队列优先权

>不合理的进程推进顺序可能产生死锁的原因是相互等待资源。如进程p1申请资源的顺序是资源1和资源2，进程p2申请资源的顺序是资源2和资源1；这时当两个进行都申请成功了第一个资源后，在申请第二个资源的时候就会出现死锁。

产生死锁的四个必要条件是：互斥、( )、循环等待和不剥夺。
- [ ] 请求与阻塞
- [x] 请求与保持
- [ ] 请求与释放
- [ ] 释放与阻塞

>互斥是一次只有一个进程可以使用一个资源，其他进程不能访问已分配给其他进程的资源；请求与保持是当一个进程等待其他进程时，继续占有已经分配的资源；不剥夺是不能强行抢占进程已占有的资源；循环等待指存在一个封闭的进程链，使得每个进程至少占有此链中下一个进程所需要的一个资源。这四个是产生死锁的必要条件。

在下列解决死锁的方法中，属于死锁预防策略的是 ( )。
- [ ] 银行家算法（死锁避免）
- [x] 资源有序分配法
- [ ] 死锁检测法
- [ ] 资源分配图化简法

>资源有序分配法将资源按某种规则系统中的所有资源统一编号，申请的时候必须按照编号的顺序申请。对进行必须使用的同类资源，必须一次申请；不同类的资源必须按照资源编号顺序申请，这样就破坏了死锁环路。

采用资源剥夺法可以解除死锁，还可以采用 ( ) 方法解除死锁。
- [ ] 执行并行操作
- [x] 撤销进程
- [ ] 拒绝分配新资源
- [ ] 修改信号量

>当检测到系统中已发生死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。

进程从运行态进入阻塞态可能是由于（）。
- [ ] 现运行进程运行结束
- [x] 现运行进程执行了P操作
- [ ] 现运行进程执行了V操作
- [ ] 现运行进程时间片用完

>p操作使信号量减1，表明程序申请了资源，当信号量小于0时，表明没有可供使用的资源，程序将从运行态进入阻塞态。

在 ( )情况下，系统出现死锁。
- [ ] 计算机系统发生了重大故障
- [ ] 有多个封锁的进程同时存在
- [x] 若干进程因竞争而无休止地相互等待他方释放已占有的资源
- [ ] 资源数远远小于进程数或进程同时申请的资源数量远远超过资源总数

>死锁产生的必要条件是互斥、请求与保持、不可抢占、循环等待。所以当若干进程因竞争而无休止地相互等待他方释放已占有的资源时，系统会产生死锁。

若信号量S的初值为2，且有三个进程共享此信号量，则S的取值范围是( )。
- [ ] [-3,2]
- [ ] [-2,2]
- [x] [-1,2]
- [ ] [0,2]

>因为s的初始值为2，而有3个进行共享信号量，所以s的最小值为2-3=-1，最大值为2-0=2。

对于记录型信号量，在执行一次P操作(wait操作)时，信号量的值应当为减1；当其值为( )时，进程应阻塞。
- [ ] 大于0
- [x] 小于0
- [ ] 大于等于0
- [ ] 小于等于0

>在执行p操作时，如果信号量的值小于0，则表明没有资源可以分配了，进行应进入等待状态。

预防死锁的论述中，（）条是正确的论述。
- [ ] 由于产生死锁的基本原因是系统资源不足，因而预防死锁的有效方法，是根据系统规模，配置足够的系统资源。
- [ ] 由于产生死锁的另一种基本原因是进程推进顺序不当，因而预防死锁的有效方法，是使进程的推进顺序合法。
- [ ] 因为只要系统不进入不安全状态，便不会产生死锁，故预防死锁的有效方法，是防止系统进入不安全状态。
- [x] 可以通过破坏产生死锁的四个必要条件之一或其中几个的方法，来预防发生死锁。

>死锁是因为若干进程因竞争而无休止地相互等待他方释放已占有的资源，通过破坏四个必要条件，可以预防死锁产生。通过增加系统资源的方法相当于增加了信号量的初始值，可以一定程度上减少死锁的出现，但是当众多进程申请同一资源时，还是会出现死锁的情况；合理的进程推进顺序可以降低死锁出现的可能，但是当四个必要条件存在时，还是有出现死锁的可能；让系统不进入安全状态是可以预防死锁，但是因为破坏了互斥关系，导致程序执行错误。

操作系统中，进程与程序的重要区别之一是( )。
- [ ] 程序有状态而进程没有
- [x] 进程有状态而程序没有
- [ ] 程序可占有资源而进程不可
- [ ] 进程能占有资源而程序不能

>进程是一个“执行中的程序”，所以进程是有状态的，而程序只是一个静态的概念，并不存在状态。

进程从阻塞状态进入就绪状态可能是由于( )。
- [ ] 现运行进程运行结束
- [ ] 现运行进程执行了P操作
- [x] 现运行进程执行了V操作
- [ ] 现运行进程时间片用完

>v操作会使信号量加1，表明有程序释放了资源，而需要该资源的一个进程会被唤醒，成阻塞状态转换成就绪状态，准备获取资源并执行。

发生死锁的必要条件有四个，要防止死锁的发生，可以破坏这四个必要条件，但破坏( )条件是不太实际的。
- [x] 互斥
- [ ] 不可抢占
- [ ] 占有且等待
- [ ] 循环等待

>互斥是不可能被禁止的，因为如果需要对资源进行互斥访问，那么操作系统必须支持互斥；预防占有且等待可以要求进行一次性请求所有需要的资源，并且阻塞这个进程直到所有请求都同时满足；对于不可抢占可以要求如果占有某些资源的一个进程进一步申请资源时被拒绝，则该进行必须释放它最初占有的资源；循环等待可以通过定义资源类型的线性顺序来预防。

(北京理工大学)资源的有序分配策略可以破坏死锁的（）条件。
- [ ] 互斥
- [ ] 请求和保持
- [ ] 不剥夺
- [x] 循环等待

>资源的有序分配策略属于死锁预防的一种，死锁预防是通过破坏4个必要条件中的1个或者多个以确保系统不会发生死锁。采用资源有序分配法是破坏了“环路”条件，即破坏了循环等待。

(南京理工大学)一进程在获得资源后，只能在使用完资源后由自己释放，这属于死锁必要条件的（）。
- [ ] 互斥条件
- [ ] 请求和释放条件
- [x] 不剥夺条件
- [ ] 环路等待条件

>死锁的必要条件包括互斥、请求和保持、不可剥夺、循环等待。如果一个程序占有的资源只能由其使用完后自己释放，则满足其中的不剥夺条件。

(四川大学)死锁产生的原因之一是：（）。
- [ ] 系统中没有采用Spooling技术
- [ ] 使用PV操作过多
- [ ] 有共享资源存在
- [x] 资源分配不当

>任何系统的资源都是有限的，所以不恰当的资源分配可能会导致死锁的产生。

(南京理工大学)计算机系统产生死锁的根本原因是（）。
- [ ] 资源有限
- [ ] 进程推进顺序不当
- [ ] 系统中进程太多
- [x] A和B

>产生死锁的原因有两个，一是系统提供的资源不能满足每个进程的使用需求；二是在多道程序运行时，进程推进顺序不合法。

(上海交通大学)某系统中有11台打印机，N个进程共享打印机资源，每个进程要求3台，当N不超过（）时，系统不会死锁。
- [ ] 4
- [x] 5
- [ ] 6
- [ ] 7

>考虑下面的极端情况，每个进程都刚好分到了2台打印机，则只需要再分到一台打印机，某个进程就可以获得该打印机，完成自己的工作，并释放所有的打印机。其他的进程就可以完成，这样，N*2+1=11,所以N=5

(电子科技大学)死锁定理是用于处理死锁的哪一种方法（）。
- [ ] 预防死锁
- [ ] 避免死锁
- [x] 检测死锁
- [ ] 解除死锁

>死锁定理是操作系统中用于检测死锁的充分必要条件的方法，所以死锁定理属于检测死锁。

(青岛大学)通常，（）是预防系统死锁的主要策略。
- [ ] 动态分配与静态分配相结合
- [ ] 静态分配与银行家算法相结合
- [ ] 死锁检测与死锁解除相结合
- [x] 静态分配、剥夺式分配和按序分配

>死锁预防是通过破坏4个必要条件中的1个或者多个以确保系统不会发生死锁。采用资源的静态预分配策略，破坏了保持和请求；运行进程剥夺使用其他进程占有的资源，从而破坏不剥夺性条件，采用资源有序分配法，破坏了循环等待条件。

(兰州大学)死锁检测检查的是（）。
- [x] 资源分配图
- [ ] 前趋图
- [ ] 搜索树
- [ ] 安全图

>如果资源分配图中不存在环路，则系统不存在死锁；反之如果资源分配图中存在环路，则系统可能存在死锁，也可能不存在死锁。

(兰州大学)采用资源剥夺法可以解除死锁，还可以采用（）方法解除死锁。
- [ ] 执行并行操作
- [x] 撤销进程
- [ ] 拒绝分配资源
- [ ] 修改信号量

>解除死锁通常的做法有三种：一是撤销处于死锁状态的进程并收回它们的资源；二是资源剥夺法；三是进程回退。所以这里选择撤销进程。

(四川大学)当进程A使用磁带机时，进程B又申请该磁带机，这种情况（）。
- [ ] 是不可能出现的
- [ ] 是没法解决的
- [ ] 就是死锁
- [x] 以上均不正确

>首先，这种情况在多道程序系统中是可能出现的，甚至是会经常出现的。同时，死锁是指多个进程因竞争资源而形成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进。通常情况下，进程都在等待彼此已经占据的资源。本题中的情况没有构成死锁。

(电子科技大学)下面关于检测死锁的正确描述是（）。
- [ ] 银行家算法是典型的检测死锁算法
- [ ] 检测死锁中系统需要反复检测各个进程资源申请和分配情况
- [ ] 检测死锁是预防卷入了死锁
- [x] 检测死锁方法对系统吱呀u年的分配不加限制，只要有则可以进行分配

>银行家算法是死锁避免算法，死锁检测方法是对资源分配不加限制，即允许死锁发生。但是系统定时地运行一个死锁检测程序，判断系统是否已发生死锁，若检测到死锁发生，则设法加以解除。

---

## 判断题

---

死锁与程序的死循环一样。
- [ ] 对
- [x] 错

>死锁是因为若干进程因竞争而无休止地相互等待他方释放已占有的资源，造成程序不能顺利执行；而程序的死循环的程序在执行逻辑上存在缺陷，导致程序不能够结束循环。

信号量机制中，P、V操作必须成对出现。
- [x] 对
- [ ] 错

>p操作为申请资源操作，p操作成功执行后，信号量会减1；v操作为释放资源操作，v操作执行成功后，信号量会加1；所有资源的申请和释放必须成对出现。

当系统同时具备了死锁的四个必要条件时就肯定会产生死锁。
- [ ] 对
- [x] 错

>在系统存在死锁的四个必要条件只是表明该系统可能会出现死锁，而不是肯定会产生死锁。在存在这四个必要条件的时候可以通过明智的选择，确保永远都不会到达死锁点。

死锁是指两个或多个进程都处于互等状态而无法继续工作。
- [x] 对
- [ ] 错

>死锁是因为若干进程因竞争而无休止地相互等待他方释放已占有的资源。

死锁避免比死锁预防对系统条件限制更严格，所以使得系统资源利用率不高。
- [ ] 对
- [x] 错

>死锁预防是通过破坏死锁的四个必要条件来预防死锁，但这样会导致低效的资源使用和低效的进程执行；死锁避免则相反，它允许死锁的互斥、占有且等待、不可抢占三个条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发，所以其资源利用率要高于死锁预防。

---
